name: Sync upstream repository

on:
  schedule:
    - cron: '0 2 * * *'  # каждый день в 2:00
  workflow_dispatch:

jobs:
  sync-upstream:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout corporate repo
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

      - name: Add upstream remote
        run: |
          git remote add upstream https://github.com/rosetta-models/blank-base-model.git || true
          git fetch upstream master

      - name: Checkout feature/upstream-updates branch
        run: git checkout feature/upstream-updates

      - name: Determine new commits
        id: new_commits
        run: |
          COMMITS=$(comm -23 <(git rev-list upstream/main | sort) <(git rev-list feature/upstream-updates | sort) | tr '\n' ' ')
          echo "new_commits=$COMMITS" >> $GITHUB_ENV
          echo "Found $(echo "$COMMITS" | wc -w) new commits"

    - name: Cherry-pick new commits
        if: env.new_commits != ''
        run: |
          # Полностью сбрасываем зависший cherry-pick
          git reset --hard || true
          git update-ref -d CHERRY_PICK_HEAD || true

          for c in ${{ env.new_commits }}; do
            echo "Applying commit $c"
            # Пробуем cherry-pick, если конфликт — жёстко перетираем всё из коммита
            while ! git cherry-pick "$c"; do
              echo "⚠️ Conflict detected. Force overwriting with theirs..."
              git checkout --theirs . || true
              git add -A || true
              git cherry-pick --continue || git cherry-pick --skip || break
            done
          done

      - name: Push changes
        if: env.new_commits != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git push https://x-access-token:${GH_TOKEN}@github.com/<org>/company-blank-base-model.git feature/upstream-updates


---
      - name: Fetch upstream
        run: |
          git fetch upstream master

      - name: Determine new commits
        id: new_commits
        run: |
          # Берём все обычные коммиты из upstream/master, которых нет в текущей ветке (merge-коммиты исключаем)
          COMMITS=$(git rev-list upstream/master ^HEAD --no-merges)
          echo "new_commits=$COMMITS" >> $GITHUB_ENV
          echo "Found $(echo "$COMMITS" | wc -w) new commits"

      - name: Cherry-pick new commits (force overwrite)
        if: env.new_commits != ''
        run: |
          # Чистим возможный зависший cherry-pick
          git reset --hard || true
          git update-ref -d CHERRY_PICK_HEAD || true

          # Применяем все коммиты один за другим
          for c in ${{ env.new_commits }}; do
            echo "Applying commit $c"
            # Любые конфликты автоматически перетираются их версией
            while ! git cherry-pick "$c"; do
              echo "⚠️ Conflict detected. Force overwriting everything with theirs..."
              git checkout --theirs . || true
              git add -A || true
              git cherry-pick --continue || git cherry-pick --skip || break
            done
          done

----

git fetch upstream --prune

$branches = git branch -r | Where-Object { $_ -match '^  upstream/' -and $_ -notmatch '->' } |
    ForEach-Object { ($_ -replace '^\s*upstream/', '').Trim() }

foreach ($branch in $branches) {
    Write-Host "Tracking branch: $branch"
    git branch --track $branch "upstream/$branch" 2>$null
}


# Обновить все локальные ветки содержимым из upstream
foreach ($branch in (git branch --format='%(refname:short)')) {
    git switch $branch
    git pull --ff-only upstream $branch 2>$null
}

# Затем запушить всё в origin
git push origin --all
git push origin --tags

---


name: Sync Upstream Branches

on:
  workflow_dispatch:  # можно запускать вручную
  schedule:
    - cron: '0 4 * * *' # опционально: ежедневный запуск в 4 утра UTC

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # чтобы видеть все ветки

      - name: Configure git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream and fetch
        run: |
          git remote add upstream https://github.com/rosetta-models/common-domain-model.git || true
          git fetch upstream --prune --tags

      - name: Sync all branches except master
        run: |
          set -euo pipefail

          # Получаем список всех веток upstream
          branches=$(git branch -r | grep '^  upstream/' | grep -v '->' | sed 's/^  upstream\///')

          for branch in $branches; do
            echo "→ Processing branch: $branch"

            # Пропускаем master
            if [[ "$branch" == "master" ]]; then
              echo "⚠️  Skipping protected branch: $branch"
              continue
            fi

            # Создаём локальную tracking-ветку, если её нет
            if ! git show-ref --verify --quiet refs/heads/$branch; then
              echo "→ Creating local branch $branch tracking upstream/$branch"
              git branch --track "$branch" "upstream/$branch" || true
            fi

            # Обновляем ветку
            git switch "$branch" >/dev/null 2>&1 || git checkout -B "$branch" "upstream/$branch"
            git pull --ff-only upstream "$branch" || true

            # Пушим в origin
            echo "→ Pushing $branch to origin"
            git push origin "$branch"
          done

          echo "→ Syncing tags..."
          git push origin --tags

          echo "✅ All branches (except master) synced successfully!"

---

      - name: Sync upstream master into sync-master
        shell: bash
        run: |
          set -euo pipefail

          echo "Fetching latest upstream master..."
          git fetch upstream master

          echo "Creating or updating sync-master from upstream/master..."
          if git show-ref --verify --quiet refs/heads/sync-master; then
            git switch sync-master
          else
            git switch -c sync-master upstream/master
          fi

          git reset --hard upstream/master
          git push origin sync-master --force

          echo "✅ sync-master branch updated from upstream/master"

---

- name: Fetch upstream (classic PAT)
  run: |
    B64=$(printf '%s' "${GITHUB_USER}:${ROSETTA_TOKEN}" | base64 | tr -d '\n')
    git -c http.extraHeader="Authorization: Basic ${B64}" \
        fetch "https://github.com/rosetta-models/${REPOSITORY}.git" \
        --prune --tags
  env:
    GITHUB_USER: my-username   # твой GitHub login
    ROSETTA_TOKEN: ${{ secrets.ROSETTA_TOKEN }}
    REPOSITORY: ISO-20022

--

- name: Configure git credentials for upstream
  if: ${{ inputs.USE_TOKEN == 'true' }}
  run: |
    echo "Setting up git credentials for upstream..."

    # Настраиваем credential helper
    git config --global credential.helper store
    git config --global credential.useHttpPath true

    # Добавляем токен как пароль для username
    git credential approve <<EOF
protocol=https
host=github.com
username=${GITHUB_USER}
password=${ROSETTA_TOKEN}
EOF

    # Добавляем upstream (если ещё нет)
    if ! git remote | grep -q upstream; then
      git remote add upstream "https://github.com/rosetta-models/${REPOSITORY}.git"
    fi

    # Делаем fetch
    git fetch upstream --prune --tags
  env:
    GITHUB_USER: ghauser1
    ROSETTA_TOKEN: ${{ secrets.ROSETTA_TOKEN }}
    REPOSITORY: ${{ inputs.REPOSITORY }}

---

- name: Setup SSH for private repo
  run: |
    mkdir -p ~/.ssh
    echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
    chmod 600 ~/.ssh/id_ed25519

    # Добавляем GitHub в known_hosts, чтобы не было запроса подтверждения
    ssh-keyscan github.com >> ~/.ssh/known_hosts

- name: Add upstream and fetch
  run: |
    # Добавляем upstream если его нет
    if ! git remote | grep -q upstream; then
      git remote add upstream git@github.com:rosetta-models/${REPOSITORY}.git
    fi

    # Fetch upstream
    git fetch upstream --prune --tags
  env:
    REPOSITORY: ISO-20022


- name: Setup SSH
  run: |
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh

    # Декодируем base64 ключ
    echo "${{ secrets.SSH_PRIVATE_KEY_BASE64 }}" | base64 --decode > ~/.ssh/id_ed25519
    chmod 600 ~/.ssh/id_ed25519

    # Добавляем GitHub в known_hosts
    ssh-keyscan github.com >> ~/.ssh/known_hosts

- name: Add upstream and fetch
  run: |
    if ! git remote | grep -q upstream; then
      git remote add upstream git@github.com:rosetta-models/${REPOSITORY}.git
    fi
    git fetch upstream --prune --tags
  env:
    REPOSITORY: ISO-20022


- name: Setup SSH offline
  run: |
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh

    # Приватный ключ
    echo "${{ secrets.SSH_PRIVATE_KEY_BASE64 }}" | base64 --decode > ~/.ssh/id_ed25519
    chmod 600 ~/.ssh/id_ed25519

    # Отключаем проверку хоста
    echo -e "Host github.com\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null" > ~/.ssh/config

echo "github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIK9XQ+Vn..." > ~/.ssh/known_hosts

---

Upstream Sync Pipeline Documentation

This page describes the GitHub Actions workflow responsible for synchronizing updates from the upstream repository (rosetta-models/blank-base-model) into our internal corporate repository.

Overview

Our project uses two related CI/CD workflows:

Shared Pipeline – the main CI pipeline used across projects for building, testing, and deployments.

Upstream Sync Pipeline – a dedicated workflow designed to fully synchronize our internal fork with the upstream repository.

This document covers the second one: Sync Upstream Repository.

Purpose

The Upstream Sync Pipeline performs a full resynchronization of our internal repository with the upstream rosetta-models codebase.
Unlike the previous implementation, we no longer cherry-pick individual commits.

The pipeline now:

performs a clean clone of the upstream repository (without preserving local master),

updates our internal tracking branch,

and separately synchronizes the upstream master branch into our local branch called sync-master.

This ensures our internal fork always has an accurate, conflict-free mirror of the upstream structure, while still keeping our internal modifications isolated.

Triggering

The workflow runs in two ways:

Daily at 02:00 UTC (via cron schedule)

Manually via workflow_dispatch

Workflow Structure
1. Clone Corporate Repository

The workflow checks out the internal repo with full history.

2. Configure Git

Sets the Git identity used for automated syncing.

3. Add Upstream Remote & Fetch

Adds rosetta-models/blank-base-model as the upstream remote and fetches all branches.

4. Full Clone of Upstream State

The pipeline completely refreshes the upstream-tracking tree:

upstream code is copied over,

local master is not used,

we maintain a clean, conflict-free state reflecting the upstream repository layout.

This ensures our fork stays structurally consistent with upstream.

5. Synchronize With Local sync-master

Separately, the workflow:

fetches upstream master,

rebases or resets our internal branch sync-master to match it,

pushes updates back to the corporate repository.

This branch is used internally as a “golden copy” of upstream master.

6. Push Updated Branches

All synced branches (including sync-master and the refreshed upstream-tracking branch) are pushed back to GitHub.

Result

The internal repository stays fully aligned with the upstream project.

sync-master always holds the latest upstream master content.

No cherry-picks or conflict-resolution loops are required.

Internal development remains isolated from the upstream mirror.

If you want, I can also prepare a more compact version, add Confluence panels/macros, or include diagrams.
